var searchIndex = {};
searchIndex["petgraph"] = {"doc":"**petgraph** is a graph data structure library.","items":[[4,"EdgeDirection","petgraph","Edge direction",null,null],[13,"Outgoing","","An `Outgoing` edge is an outward edge *from* the current node.",0,null],[13,"Incoming","","An `Incoming` edge is an inbound edge *to* the current node.",0,null],[4,"Directed","","Marker type for a directed graph.",null,null],[4,"Undirected","","Marker type for an undirected graph.",null,null],[0,"algo","","Graph algorithms.",null,null],[5,"is_isomorphic","petgraph::algo","Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_isomorphic_matching","","Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"},{"name":"f"},{"name":"g"}],"output":{"name":"bool"}}],[5,"dijkstra","","Dijkstra&#39;s shortest path algorithm.",null,{"inputs":[{"name":"g"},{"name":"nodeid"},{"name":"option"},{"name":"f"}],"output":{"name":"hashmap"}}],[5,"is_cyclic_undirected","","Return `true` if the input graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic","","**Deprecated: Renamed to `is_cyclic_undirected`.**",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic_directed","","Return `true` if the input directed graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"toposort","","Perform a topological sort of a directed graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"scc","","Compute the *strongly connected components* using Kosaraju&#39;s algorithm.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"condensation","","Condense every strongly connected component into a single node and return the result.",null,{"inputs":[{"name":"graph"},{"name":"bool"}],"output":{"name":"graph"}}],[5,"connected_components","","Return the number of connected components of the graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[5,"min_spanning_tree","","Compute a *minimum spanning tree* of a graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[0,"generate","petgraph","***Unstable.*** Graph generation.",null,null],[3,"Generator","petgraph::generate","A graph generator of “all” graphs of a particular size.",null,null],[11,"directed_acyclic","","Generate all possible Directed acyclic graphs (DAGs) of a particular number of vertices.",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"all","","Generate all possible graphs of a particular number of vertices.",1,{"inputs":[{"name":"usize"},{"name":"bool"}],"output":{"name":"self"}}],[11,"next_ref","","",1,null],[11,"next","","",1,null],[0,"graphmap","petgraph","`GraphMap&lt;N, E&gt;` is an undirected graph where node values are mapping keys.",null,null],[3,"GraphMap","petgraph::graphmap","`GraphMap&lt;N, E&gt;` is an undirected graph, with generic node values `N` and edge weights `E`.",null,null],[3,"Nodes","","",null,null],[3,"Neighbors","","",null,null],[3,"Edges","","",null,null],[3,"AllEdges","","",null,null],[3,"Ptr","","A reference that is hashed and compared by its pointer value.",null,null],[12,"0","","",2,null],[8,"NodeTrait","","A trait group for `GraphMap`&#39;s node identifier.",null,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"new","","Create a new `GraphMap`.",3,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `GraphMap` with estimated capacity.",3,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",3,null],[11,"from_edges","","Create a new `GraphMap` from an iterable of edges.",3,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes in the graph.",3,null],[11,"edge_count","","Return the number of edges in the graph.",3,null],[11,"clear","","Remove all nodes and edges",3,null],[11,"add_node","","Add node `n` to the graph.",3,null],[11,"remove_node","","Return `true` if node `n` was removed.",3,null],[11,"contains_node","","Return `true` if the node is contained in the graph.",3,null],[11,"add_edge","","Add an edge connecting `a` and `b` to the graph, with associated\ndata `weight`.",3,null],[11,"remove_edge","","Remove edge from `a` to `b` from the graph and return the edge weight.",3,null],[11,"contains_edge","","Return `true` if the edge connecting `a` with `b` is contained in the graph.",3,null],[11,"nodes","","Return an iterator over the nodes of the graph.",3,null],[11,"neighbors","","Return an iterator over the nodes that are connected with `from` by edges.",3,null],[11,"edges","","Return an iterator over the nodes that are connected with `from` by edges,\npaired with the edge weight.",3,null],[11,"edge_weight","","Return a reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",3,null],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",3,null],[11,"all_edges","","Return an iterator over all edges of the graph with their weight in arbitrary order.",3,null],[11,"from_iter","","",3,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null],[11,"clone","","",5,null],[11,"next","","",6,null],[11,"next","","",7,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",2,null],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",2,null],[11,"partial_cmp","","",2,null],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",2,null],[11,"deref","","",2,null],[11,"hash","","",2,null],[11,"fmt","","",2,null],[0,"graph","petgraph","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"NodeIndex","petgraph::graph","Node identifier.",null,null],[3,"EdgeIndex","","Edge identifier.",null,null],[3,"Node","","The graph&#39;s node type.",null,null],[12,"weight","","Associated node data.",8,null],[3,"Edge","","The graph&#39;s edge type.",null,null],[12,"weight","","Associated edge data.",9,null],[3,"Graph","","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"Externals","","An iterator over either the nodes without edges to them or from them.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"Edges","","Iterator over the edges of a node.",null,null],[3,"NodeWeightsMut","","Iterator yielding mutable access to all node weights.",null,null],[3,"EdgeWeightsMut","","Iterator yielding mutable access to all edge weights.",null,null],[3,"WalkNeighbors","","A “walker” object that can be used to step through the edge list of a node.",null,null],[3,"WalkEdges","","**Deprecated.**",null,null],[3,"NodeIndices","","Iterator over the node indices of a graph.",null,null],[3,"EdgeIndices","","Iterator over the edge indices of a graph.",null,null],[5,"node_index","","Short version of `NodeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[5,"edge_index","","Short version of `EdgeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[0,"stable","","***Unstable.*** `StableGraph` keeps indices stable across removals.",null,null],[3,"StableGraph","petgraph::graph::stable","`StableGraph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency\nlist representation.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"WalkNeighbors","","A “walker” object that can be used to step through the edge list of a node.",null,null],[3,"NodeIndices","","Iterator over the node indices of a graph.",null,null],[11,"fmt","","",10,null],[11,"new","","Create a new `StableGraph` with directed edges.",10,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `StableGraph` with estimated capacity.",10,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",10,null],[11,"clear","","Remove all nodes and edges",10,null],[11,"node_count","","Return the number of nodes (vertices) in the graph.",10,null],[11,"edge_count","","Return the number of edges in the graph.",10,null],[11,"is_directed","","Whether the graph has directed edges or not.",10,null],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",10,null],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",10,null],[11,"contains_node","","",10,null],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",10,null],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",10,null],[11,"node_weight","","Access the weight for node `a`.",10,null],[11,"node_weight_mut","","Access the weight for node `a`, mutably.",10,null],[11,"node_indices","","Return an iterator over the node indices of the graph",10,null],[11,"edge_weight","","Access the weight for edge `e`.",10,null],[11,"edge_weight_mut","","Access the weight for edge `e`, mutably",10,null],[11,"edge_endpoints","","Access the source and target nodes for `e`.",10,null],[11,"find_edge","","Lookup an edge from `a` to `b`.",10,null],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",10,null],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",10,null],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and `a`,\nin either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",10,null],[11,"clone","","",10,null],[11,"clone_from","","",10,null],[11,"index","","",10,null],[11,"index_mut","","",10,null],[11,"index","","",10,null],[11,"index_mut","","",10,null],[11,"default","","",10,{"inputs":[],"output":{"name":"self"}}],[11,"detach","","Return a “walker” object that can be used to step through the\nneighbors and edges from the origin node.",11,null],[11,"next","","",11,null],[11,"next","","Step to the next edge and its endpoint node in the walk for graph `g`.",12,null],[11,"next_node","","",12,null],[11,"next_edge","","",12,null],[11,"next","","",13,null],[11,"next_back","","",13,null],[6,"DefIndex","petgraph::graph","The default integer type for node and edge indices in `Graph`.\n`u32` is the default to reduce the size of the graph&#39;s data and improve\nperformance in the common case.",null,null],[8,"IndexType","","Trait for the unsigned integer type used for node and edge indices.",null,null],[10,"new","","",14,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[10,"index","","",14,null],[10,"max","","",14,{"inputs":[],"output":{"name":"self"}}],[8,"GraphIndex","","A  `GraphIndex` is a node or edge index.",null,null],[11,"clone","","",15,null],[11,"fmt","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"partial_cmp","","",15,null],[11,"lt","","",15,null],[11,"le","","",15,null],[11,"gt","","",15,null],[11,"ge","","",15,null],[11,"cmp","","",15,null],[11,"hash","","",15,null],[11,"new","","",15,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",15,null],[11,"end","","",15,{"inputs":[],"output":{"name":"self"}}],[11,"from","","",15,{"inputs":[{"name":"ix"}],"output":{"name":"self"}}],[11,"clone","","",16,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"partial_cmp","","",16,null],[11,"lt","","",16,null],[11,"le","","",16,null],[11,"gt","","",16,null],[11,"ge","","",16,null],[11,"cmp","","",16,null],[11,"hash","","",16,null],[11,"new","","",16,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",16,null],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",16,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",16,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",8,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",9,null],[11,"source","","Return the source node index.",9,null],[11,"target","","Return the target node index.",9,null],[11,"clone","","",17,null],[11,"clone_from","","",17,null],[11,"fmt","","",17,null],[11,"new","","Create a new `Graph` with directed edges.",17,{"inputs":[],"output":{"name":"self"}}],[11,"new_undirected","","Create a new `Graph` with undirected edges.",17,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `Graph` with estimated capacity.",17,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes (vertices) in the graph.",17,null],[11,"edge_count","","Return the number of edges in the graph.",17,null],[11,"is_directed","","Whether the graph has directed edges or not.",17,null],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",17,null],[11,"node_weight","","Access the weight for node `a`.",17,null],[11,"node_weight_mut","","Access the weight for node `a`, mutably.",17,null],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",17,null],[11,"update_edge","","Add or update an edge from `a` to `b`.\nIf the edge already exists, its weight is updated.",17,null],[11,"edge_weight","","Access the weight for edge `e`.",17,null],[11,"edge_weight_mut","","Access the weight for edge `e`, mutably.",17,null],[11,"edge_endpoints","","Access the source and target nodes for `e`.",17,null],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",17,null],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",17,null],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",17,null],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",17,null],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and `a`,\nin either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",17,null],[11,"edges","","Return an iterator over the neighbors of node `a`, paired with their respective edge\nweights.",17,null],[11,"edges_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction, paired with the respective edge weights.",17,null],[11,"find_edge","","Lookup an edge from `a` to `b`.",17,null],[11,"find_edge_undirected","","Lookup an edge between `a` and `b`, in either direction.",17,null],[11,"externals","","Return an iterator over either the nodes without edges to them\n(`Incoming`) or from them (`Outgoing`).",17,null],[11,"node_indices","","Return an iterator over the node indices of the graph",17,null],[11,"node_weights_mut","","Return an iterator yielding mutable access to all node weights.",17,null],[11,"edge_indices","","Return an iterator over the edge indices of the graph",17,null],[11,"edge_weights_mut","","Return an iterator yielding mutable access to all edge weights.",17,null],[11,"raw_nodes","","Access the internal node array.",17,null],[11,"raw_edges","","Access the internal edge array.",17,null],[11,"into_nodes_edges","","Convert the graph into a vector of Nodes and a vector of Edges",17,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",17,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",17,null],[11,"walk_edges_directed","","**Deprecated:** Use [`.neighbors_directed(a, dir).detach()`][1] instead.",17,null],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",17,null],[11,"reverse","","Reverse the direction of all edges",17,null],[11,"clear","","Remove all nodes and edges",17,null],[11,"clear_edges","","Remove all edges",17,null],[11,"capacity","","Return the current node and edge capacity of the graph.",17,null],[11,"reserve_nodes","","Reserves capacity for at least `additional` more nodes to be inserted in\nthe graph. Graph may reserve more space to avoid frequent reallocations.",17,null],[11,"reserve_edges","","Reserves capacity for at least `additional` more edges to be inserted in\nthe graph. Graph may reserve more space to avoid frequent reallocations.",17,null],[11,"reserve_exact_nodes","","Reserves the minimum capacity for exactly `additional` more nodes to be\ninserted in the graph. Does nothing if the capacity is already\nsufficient.",17,null],[11,"reserve_exact_edges","","Reserves the minimum capacity for exactly `additional` more edges to be\ninserted in the graph.\nDoes nothing if the capacity is already sufficient.",17,null],[11,"shrink_to_fit_nodes","","Shrinks the capacity of the underlying nodes collection as much as possible.",17,null],[11,"shrink_to_fit_edges","","Shrinks the capacity of the underlying edges collection as much as possible.",17,null],[11,"shrink_to_fit","","Shrinks the capacity of the graph as much as possible.",17,null],[11,"retain_nodes","","Keep all nodes that return `true` from the `visit` closure,\nremove the others.",17,null],[11,"retain_edges","","Keep all edges that return `true` from the `visit` closure,\nremove the others.",17,null],[11,"from_edges","","Create a new `Graph` from an iterable of edges.",17,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend_with_edges","","Extend the graph from an iterable of edges.",17,null],[11,"map","","Create a new `Graph` by mapping node and\nedge weights to new values.",17,null],[11,"filter_map","","Create a new `Graph` by mapping nodes and edges.\nA node or edge may be mapped to `None` to exclude it from\nthe resulting graph.",17,null],[11,"into_edge_type","","Convert the graph into either undirected or directed. No edge adjustments\nare done, so you may want to go over the result to remove or add edges.",17,null],[11,"next","","",18,null],[11,"next","","",19,null],[11,"clone","","",19,null],[11,"detach","","Return a “walker” object that can be used to step through the\nneighbors and edges from the origin node.",19,null],[11,"next","","",20,null],[11,"clone","","",20,null],[11,"next","","",21,null],[11,"size_hint","","",21,null],[11,"next","","",22,null],[11,"size_hint","","",22,null],[11,"index","","",17,null],[11,"index_mut","","",17,null],[11,"index","","",17,null],[11,"index_mut","","",17,null],[11,"default","","",17,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",15,null],[11,"is_node_index","","",15,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",16,null],[11,"is_node_index","","",16,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",23,null],[11,"next","","Step to the next edge and its endpoint node in the walk for graph `g`.",23,null],[11,"next_node","","",23,null],[11,"next_edge","","",23,null],[11,"clone","","",24,null],[11,"fmt","","",24,null],[11,"next","","Fetch the next edge index in the walk for graph `g`.",24,null],[11,"next_neighbor","","Fetch the next edge index and the next node index in the walk for graph `g`.",24,null],[11,"clone","","",25,null],[11,"fmt","","",25,null],[11,"next","","",25,null],[11,"size_hint","","",25,null],[11,"next_back","","",25,null],[11,"clone","","",26,null],[11,"fmt","","",26,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"next_back","","",26,null],[0,"dot","petgraph","Simple graphviz dot file format output.",null,null],[3,"Dot","petgraph::dot","`Dot` implements output to graphviz .dot format for a graph.",null,null],[4,"Config","","`Dot` configuration.",null,null],[13,"NodeIndexLabel","","Use indices for node labels.",27,null],[13,"EdgeIndexLabel","","Use indices for edge labels.",27,null],[13,"EdgeNoLabel","","Use no edge labels.",27,null],[11,"new","","Create a `Dot` formatting wrapper with default configuration.",28,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"with_config","","Create a `Dot` formatting wrapper with custom configuration.",28,null],[11,"fmt","","",27,null],[11,"eq","","",27,null],[11,"ne","","",27,null],[11,"fmt","","",28,null],[11,"fmt","","",28,null],[11,"fmt","","",28,null],[11,"fmt","","",28,null],[0,"visit","petgraph","Graph visitor algorithms.",null,null],[3,"AsUndirected","petgraph::visit","Wrapper type for walking the graph as if it is undirected",null,null],[12,"0","","",29,null],[3,"Reversed","","Wrapper type for walking the graph as if all edges are reversed.",null,null],[12,"0","","",30,null],[3,"Dfs","","A depth first search (DFS) of a graph.",null,null],[12,"stack","","The stack of nodes to visit",31,null],[12,"discovered","","The map of discovered nodes",31,null],[3,"DfsIter","","An iterator for a depth first traversal of a graph.",null,null],[3,"Bfs","","A breadth first search (BFS) of a graph.",null,null],[12,"stack","","The queue of nodes to visit",32,null],[12,"discovered","","The map of discovered nodes",32,null],[3,"BfsIter","","An iterator for a breadth first traversal of a graph.",null,null],[3,"Topo","","A topological order traversal for a graph.",null,null],[3,"SubTopo","","A topological order traversal for a subgraph.",null,null],[8,"Graphlike","","Base trait for graphs that defines the node identifier.",null,null],[16,"NodeId","","",33,null],[8,"NeighborIter","","`NeighborIter` gives access to the neighbors iterator.",null,null],[16,"Iter","","",34,null],[10,"neighbors","","Return an iterator that visits all neighbors of the node **n**.",34,null],[8,"NeighborsDirected","","`NeighborsDirected` gives access to neighbors of both `Incoming` and\n`Outgoing` edges of a node.",null,null],[16,"NeighborsDirected","","",35,null],[10,"neighbors_directed","","Return an iterator that visits all neighbors of the node **n**.",35,null],[8,"Externals","","Externals returns an iterator of all nodes that either have either no\nincoming or no outgoing edges.",null,null],[16,"Externals","","",36,null],[10,"externals","","Return an iterator of all nodes with no edges in the given direction",36,null],[8,"VisitMap","","A mapping for storing the visited status for `NodeId` `N`.",null,null],[10,"visit","","Return **true** if the value is not already present.",37,null],[10,"is_visited","","",37,null],[8,"Visitable","","A graph that can create a visitor map.",null,null],[16,"Map","","",38,null],[10,"visit_map","","",38,null],[8,"Revisitable","","A graph that can reset and resize its visitor map.",null,null],[10,"reset_map","","",39,null],[8,"GetAdjacencyMatrix","","Create or access the adjacency matrix of a graph",null,null],[16,"AdjMatrix","","",40,null],[10,"adjacency_matrix","","",40,null],[10,"is_adjacent","","",40,null],[11,"neighbors","petgraph::graph","",17,null],[11,"neighbors","petgraph::graph::stable","",10,null],[11,"neighbors","petgraph::graphmap","",3,null],[11,"neighbors","petgraph::visit","",29,null],[11,"neighbors","","",30,null],[11,"neighbors_directed","petgraph::graph","",17,null],[11,"neighbors_directed","petgraph::graph::stable","",10,null],[11,"neighbors_directed","petgraph::visit","",30,null],[11,"externals","petgraph::graph","",17,null],[11,"externals","petgraph::visit","",30,null],[11,"visit_map","petgraph::graph","",17,null],[11,"reset_map","","",17,null],[11,"visit_map","petgraph::graph::stable","",10,null],[11,"reset_map","","",10,null],[11,"reset_map","petgraph::visit","",30,null],[11,"visit_map","petgraph::graphmap","",3,null],[11,"reset_map","","",3,null],[11,"visit_map","petgraph::visit","",29,null],[11,"visit_map","","",30,null],[11,"adjacency_matrix","petgraph::graphmap","",3,null],[11,"is_adjacent","","",3,null],[11,"clone","petgraph::visit","",31,null],[11,"fmt","","",31,null],[11,"new","","Create a new **Dfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",31,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"empty","","Create a new **Dfs** using the graph&#39;s visitor map, and no stack.",31,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",31,null],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",31,null],[11,"new","","",41,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",41,null],[11,"next","","",41,null],[11,"size_hint","","",41,null],[11,"clone","","",41,null],[11,"clone","","",32,null],[11,"new","","Create a new **Bfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",32,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",32,null],[11,"new","","",42,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"next","","",42,null],[11,"size_hint","","",42,null],[11,"clone","","",42,null],[11,"clone","","",43,null],[11,"new","","Create a new `Topo`, using the graph&#39;s visitor map, and put all\ninitial nodes in the to-visit list.",43,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"reset","","Clear visited state, and put all initial nodes into the visit list.",43,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",43,null],[11,"clone","","",44,null],[11,"from_node","","Create a new `SubTopo`, using the graph&#39;s visitor map, and put single\nnode in the to-visit list.",44,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"reset_with_node","","Clear visited state, and put a single node into the visit list.",44,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",44,null],[0,"unionfind","petgraph","`UnionFind&lt;K&gt;` is a disjoint-set data structure.",null,null],[3,"UnionFind","petgraph::unionfind","`UnionFind&lt;K&gt;` is a disjoint-set data structure. It tracks set membership of *n* elements\nindexed from *0* to *n - 1*. The scalar type is `K` which must be an unsigned integer type.",null,null],[11,"fmt","","",45,null],[11,"clone","","",45,null],[11,"new","","Create a new `UnionFind` of `n` disjoint sets.",45,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"find","","Return the representative for `x`.",45,null],[11,"find_mut","","Return the representative for `x`.",45,null],[11,"union","","Unify the two sets containing `x` and `y`.",45,null],[11,"into_labeling","","Return a vector mapping each element to its representative.",45,null],[11,"adjacency_matrix","petgraph::graph","",17,null],[11,"is_adjacent","","",17,null],[8,"EdgeType","petgraph","A graph&#39;s edge type determines whether is has directed edges or not.",null,null],[10,"is_directed","","",46,{"inputs":[],"output":{"name":"bool"}}],[8,"IntoWeightedEdge","","Convert an element like `(i, j)` or `(i, j, w)` into\na triple of source, target, edge weight.",null,null],[16,"NodeId","","",47,null],[10,"into_weighted_edge","","",47,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"hash","","",0,null],[11,"opposite","","Return the opposite `EdgeDirection`.",0,null],[11,"clone","","",48,null],[11,"fmt","","",48,null],[11,"clone","","",49,null],[11,"fmt","","",49,null],[11,"is_directed","","",48,{"inputs":[],"output":{"name":"bool"}}],[11,"is_directed","","",49,{"inputs":[],"output":{"name":"bool"}}]],"paths":[[4,"EdgeDirection"],[3,"Generator"],[3,"Ptr"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"Edges"],[3,"AllEdges"],[3,"Node"],[3,"Edge"],[3,"StableGraph"],[3,"Neighbors"],[3,"WalkNeighbors"],[3,"NodeIndices"],[8,"IndexType"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Graph"],[3,"Externals"],[3,"Neighbors"],[3,"Edges"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"],[3,"WalkNeighbors"],[3,"WalkEdges"],[3,"NodeIndices"],[3,"EdgeIndices"],[4,"Config"],[3,"Dot"],[3,"AsUndirected"],[3,"Reversed"],[3,"Dfs"],[3,"Bfs"],[8,"Graphlike"],[8,"NeighborIter"],[8,"NeighborsDirected"],[8,"Externals"],[8,"VisitMap"],[8,"Visitable"],[8,"Revisitable"],[8,"GetAdjacencyMatrix"],[3,"DfsIter"],[3,"BfsIter"],[3,"Topo"],[3,"SubTopo"],[3,"UnionFind"],[8,"EdgeType"],[8,"IntoWeightedEdge"],[4,"Directed"],[4,"Undirected"]]};
searchIndex["fixedbitset"] = {"doc":"**FixedBitSet** is a simple fixed size set of bits.","items":[[3,"FixedBitSet","fixedbitset","**FixedBitSet** is a simple fixed size set of bits that can\nbe enabled (1 / **true**) or disabled (0 / **false**).",null,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"cmp","","",0,null],[11,"hash","","",0,null],[11,"with_capacity","","Create a new **FixedBitSet** with a specific number of bits,\nall initially clear.",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"grow","","Grow capacity to **bits**, all new bits initialized to zero",0,null],[11,"len","","Return the length of the **FixedBitSet** in bits.",0,null],[11,"contains","","Return **true** if the bit is enabled in the **FixedBitSet**,\n**false** otherwise.",0,null],[11,"clear","","Clear all bits.",0,null],[11,"insert","","**Panics** if **bit** is out of bounds.",0,null],[11,"set","","**Panics** if **bit** is out of bounds.",0,null],[11,"as_slice","","View the bitset as a slice of `u32` blocks",0,null],[11,"as_mut_slice","","View the bitset as a mutable slice of `u32` blocks. Writing past the bitlength in the last\nwill cause `contains` to return potentially incorrect results for bits past the bitlength.",0,null],[11,"clone","","",0,null],[11,"index","","",0,null]],"paths":[[3,"FixedBitSet"]]};
initSearch(searchIndex);
